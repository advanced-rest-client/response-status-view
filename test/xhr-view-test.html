<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../iron-test-helpers/mock-interactions.js"></script>
    <link rel="import" href="../response-status-view.html">
  </head>
  <body>

    <test-fixture id="xhr">
      <template>
        <response-status-view is-xhr></response-status-view>
      </template>
    </test-fixture>

    <script>
    suite('basic', () => {
      let element;
      setup(() => {
        element = fixture('xhr');
      });

      test('Updates status message after status code change', (done) => {
        element.statusCode = 200;
        setTimeout(() => {
          assert.equal(element.statusMessage, 'OK');
          done();
        }, 105);
      });

      test('Renders only 2 tabs', (done) => {
        flush(() => {
          const tabs = element.shadowRoot.querySelectorAll('paper-tab');
          assert.equal(tabs.length, 2);
          done();
        });
      });

      test('Redirects panel is not rendered', (done) => {
        flush(() => {
          const panel = element.shadowRoot.querySelector('response-redirects-panel');
          assert.notOk(panel);
          done();
        });
      });

      test('Timings panel is not rendered', (done) => {
        flush(() => {
          const panel = element.shadowRoot.querySelector('request-timings-panel');
          assert.notOk(panel);
          done();
        });
      });

      test('isError is set', () => {
        assert.isFalse(element.isError);
      });

      test('Selects first tab when `isXhr` changes', () => {
        element.isXhr = false;
        element.selectedTab = 2;
        element.isXhr = true;
        assert.equal(element.selectedTab, 0);
      });
    });

    suite('Badges', () => {
      let element;
      const badgeCls = 'badge';
      const badgeClsEmpty = badgeCls + ' empty';
      suiteSetup(() => {
        element = fixture('xhr');
      });

      test('Computes badge class for undefined', () => {
        const result = element._computeBageClass();
        assert.equal(result, badgeClsEmpty);
      });

      test('Computes badge class for empty string', () => {
        const result = element._computeBageClass('');
        assert.equal(result, badgeClsEmpty);
      });

      test('Computes badge class for "0"', () => {
        const result = element._computeBageClass(0);
        assert.equal(result, badgeClsEmpty);
      });

      test('Computes badge class for any string', () => {
        const result = element._computeBageClass('test');
        assert.equal(result, badgeCls);
      });

      test('Computes badge class for "1"', () => {
        const result = element._computeBageClass(1);
        assert.equal(result, badgeCls);
      });

      test('Computes size of empty headers', () => {
        const result = element._computeHeadersLength('');
        assert.equal(result, 0);
      });

      test('Computes size of undefined headers', () => {
        const result = element._computeHeadersLength('');
        assert.equal(result, 0);
      });

      test('Computes size of defined headers', () => {
        const result = element._computeHeadersLength('x-a:1\nx-b:2');
        assert.equal(result, 2);
      });
    });

    suite('Errored response', () => {
      let element;

      test('isError is computed', () => {
        element = fixture('xhr');
        element.responseError = new Error('Test error');
        assert.isTrue(element.isError);
      });

      test('Detail toggle is not rendered', (done) => {
        element = fixture('xhr');
        element.responseError = new Error('Test error');
        flush(() => {
          const button = element.shadowRoot.querySelector('.toggle-button');
          assert.notOk(button);
          done();
        });
      });

      test('Renders error label', (done) => {
        element = fixture('xhr');
        element.responseError = new Error('Test error');
        flush(() => {
          const label = element.shadowRoot.querySelector('.response-error-label');
          assert.ok(label);
          done();
        });
      });

      test('Closes opened collapse when opened', () => {
        element = fixture('xhr');
        element.opened = true;
        element.responseError = new Error('Test error');
        assert.isFalse(element.opened);
      });

      test('Response time label is hidden when no timing', (done) => {
        element = fixture('xhr');
        element.responseError = new Error('Test error');
        flush(() => {
          const label = element.shadowRoot.querySelector('.response-time');
          const display = getComputedStyle(label).display;
          assert.equal(display, 'none');
          done();
        });
      });
    });

    suite('HTTP source message', () => {
      let element;
      const message = `GET /path HTTP/1.1
      Host: domain.com

      `;
      setup(() => {
        element = fixture('xhr');
      });

      test('hasHttpMessage is undefined by default', () => {
        assert.isUndefined(element.hasHttpMessage);
      });

      test('Computes hasHttpMessage states', () => {
        element.httpMessage = message;
        assert.isTrue(element.hasHttpMessage, 'hasHttpMessage is true');
        element.httpMessage = undefined;
        assert.isFalse(element.hasHttpMessage, 'hasHttpMessage is false');
      });

      test('Renders http-source-message-view panel', (done) => {
        element.httpMessage = message;
        flush(() => {
          const panel = element.shadowRoot.querySelector('http-source-message-view');
          assert.ok(panel);
          done();
        });
      });
    });

    suite('Request headers', () => {
      let element;
      const headers = `Host: domain.com
      Accept: application/json
      Location: https://domainl.com`;
      setup(() => {
        element = fixture('xhr');
      });

      test('hasRequestHeaders is false by default', () => {
        assert.isFalse(element.hasRequestHeaders);
      });

      test('Computes hasHttpMessage states', () => {
        element.requestHeaders = headers;
        assert.isTrue(element.hasRequestHeaders, 'hasRequestHeaders is true');
        element.requestHeaders = undefined;
        assert.isFalse(element.hasRequestHeaders, 'hasRequestHeaders is false');
      });

      test('Renders headers-list-view panel', (done) => {
        element.requestHeaders = headers;
        flush(() => {
          const panel = element.shadowRoot.querySelector('headers-list-view[data-source="request-headers"]');
          assert.ok(panel);
          done();
        });
      });

      test('Renders empty info message', (done) => {
        flush(() => {
          const panel = element.shadowRoot.querySelector('.request-headers-panel .no-info');
          assert.ok(panel);
          done();
        });
      });
    });

    suite('Response headers', () => {
      let element;
      const headers = `Host: domain.com
      Accept: application/json
      Location: https://domainl.com`;
      setup(() => {
        element = fixture('xhr');
      });

      test('hasResponseHeaders is false by default', () => {
        assert.isFalse(element.hasResponseHeaders);
      });

      test('Computes hasResponseHeaders states', () => {
        element.responseHeaders = headers;
        assert.isTrue(element.hasResponseHeaders, 'hasResponseHeaders is true');
        element.responseHeaders = undefined;
        assert.isFalse(element.hasResponseHeaders, 'hasResponseHeaders is false');
      });

      test('Renders headers-list-view panel', (done) => {
        element.responseHeaders = headers;
        flush(() => {
          const panel = element.shadowRoot.querySelector('headers-list-view[data-source="response-headers"]');
          assert.ok(panel);
          done();
        });
      });

      test('Renders empty info message', (done) => {
        flush(() => {
          const panel = element.shadowRoot.querySelector('.response-headers-panel .no-info');
          assert.ok(panel);
          done();
        });
      });
    });

    suite('_computeToggleIconClass()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('xhr');
      });

      test('Class name when not opened', () => {
        const result = element._computeToggleIconClass(false);
        assert.equal(result, 'toggle-icon');
      });

      test('Class name when opened', () => {
        const result = element._computeToggleIconClass(true);
        assert.equal(result, 'toggle-icon opened');
      });
    });

    a11ySuite('xhr');
    </script>

  </body>
</html>
